{-# LANGUAGE DeriveAnyClass       #-}
{-# LANGUAGE DeriveFoldable       #-}
{-# LANGUAGE DeriveFunctor        #-}
{-# LANGUAGE DeriveGeneric        #-}
{-# LANGUAGE DeriveTraversable    #-}
{-# LANGUAGE FlexibleInstances    #-}
{-# LANGUAGE GADTs                #-}
{-# LANGUAGE LambdaCase           #-}
{-# LANGUAGE PatternSynonyms      #-}
{-# LANGUAGE ScopedTypeVariables  #-}
{-# LANGUAGE TemplateHaskell      #-}
{-# LANGUAGE TypeApplications     #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE ViewPatterns         #-}
module Example.Expr where

import           Control.Monad.Free
import           Control.Monad.Free.Parallel
import qualified Data.Array.Accelerate       as Acc
import           GHC.Generics                (Generic)
import           Text.Show.Deriving

-- | A generating functor for simple expresssions.
data ExprF a
  = LitF Int    -- ^ Integer literal.
  | AddF a a    -- ^ Addition.
  | MulF a a    -- ^ Multiplication.
  deriving (Eq, Show, Functor, Foldable, Traversable, Generic, Acc.Elt)
deriveShow1 ''ExprF
Acc.mkPattern ''ExprF

-- | Simple expressions are freely generated by @'ExprF'@.
type Expr a = Free ExprF a

-- | For convenience, simple expressions are also numbers.
instance Num (Expr a) where
  fromInteger = Free . LitF . fromInteger
  x + y = Free (AddF x y)
  x * y = Free (MulF x y)
  abs    = error "abs is not implemented for Expr"
  signum = error "signum is not implemented for Expr"
  negate = error "negate is not implemented for Expr"

-- | A variable for simple expressions.
var :: Char -> Expr Char
var = Pure

-- | Pretty-print an expression.
--
-- >>> ppExpr ((var 'z' + 5) * (1 + var 'x' * (3 + var 'y')))
-- "(z + 5) * (1 + x * (3 + y))"
ppExpr :: Expr Char -> String
ppExpr = ppExprPrec 0
  where
    ppExprPrec prec = \case
      Pure x          -> [x]
      Free (LitF n)   -> show n
      Free (AddF x y) -> ppBinOpPrec 1 " + " x y
      Free (MulF x y) -> ppBinOpPrec 2 " * " x y
      where
        ppBinOpPrec opPrec op x y =
          parensIf (prec > opPrec) (ppExprPrec opPrec x <> op <> ppExprPrec opPrec y)

    parensIf True s  = "(" <> s <> ")"
    parensIf False s = s

-- | An example expression.
--
-- >>> ppExpr example
-- "(z + 5) * (1 + x * (3 + y))"
--
-- We can collect the nodes with depths and print the tree structure of this expression:
--
-- >>> putStr $ ppNodesWithDepth $ collectNodesWithDepth example
-- Op (MulF () ())
-- ├─ Op (AddF () ())
-- │  ├─ Var 'z'
-- │  └─ Op (LitF 5)
-- └─ Op (AddF () ())
--    ├─ Op (LitF 1)
--    └─ Op (MulF () ())
--       ├─ Var 'x'
--       └─ Op (AddF () ())
--          ├─ Op (LitF 3)
--          └─ Var 'y'
--
-- And we can construct its data parallel representation:
--
-- >>> putStr $ ppFreeP $ fromFree' example
-- 0 	   [ 1, 0, 0, 0, 	 Op (MulF () ())
-- 1 	     1, 1, 0, 0, 	 Op (AddF () ())
-- 2 	     1, 1, 1, 0, 	 Var 'z'
-- 2 	     1, 1, 2, 0, 	 Op (LitF 5)
-- 1 	     1, 2, 0, 0, 	 Op (AddF () ())
-- 2 	     1, 2, 3, 0, 	 Op (LitF 1)
-- 2 	     1, 2, 4, 0, 	 Op (MulF () ())
-- 3 	     1, 2, 4, 1, 	 Var 'x'
-- 3 	     1, 2, 4, 2, 	 Op (AddF () ())
-- 4 	     1, 2, 4, 2, 	 Op (LitF 3)
-- 4 	     1, 2, 4, 2] 	 Var 'y'
example :: Expr Char
example = (var 'z' + 5) * (1 + var 'x' * (3 + var 'y'))
